<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Translator</title>
    <style>
        :root { --primary: #007aff; --bg: #ffffff; }
        body { font-family: -apple-system, sans-serif; background: var(--bg); margin: 0; padding: 20px; display: flex; flex-direction: column; align-items: center; }
        .container { width: 100%; max-width: 500px; }
        input { width: 100%; padding: 12px; border-radius: 8px; border: 1px solid #d2d2d7; box-sizing: border-box; font-size: 14px; background: #f5f5f7; margin-bottom: 24px; }
        .main { display: flex; flex-direction: column; align-items: center; margin-bottom: 40px; }
        #btn { background: var(--primary); color: white; border: none; width: 72px; height: 72px; border-radius: 50%; font-size: 28px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: 0.2s; }
        #btn.rec { background: #ff3b30; transform: scale(1.1); box-shadow: 0 0 15px rgba(255,59,48,0.5); }
        #status { margin-top: 12px; font-size: 13px; color: #86868b; height: 1.2em; }
        h3 { font-size: 18px; border-bottom: 1px solid #d2d2d7; padding-bottom: 8px; display: flex; justify-content: space-between; }
        .item { border-bottom: 1px solid #f5f5f7; padding: 12px 0; }
        .label { font-size: 10px; font-weight: bold; color: #86868b; text-transform: uppercase; }
        .in { font-size: 15px; margin-bottom: 4px; color: #000; }
        .out { font-size: 17px; color: var(--primary); font-weight: 600; cursor: pointer; }
        .notion-settings { margin-bottom: 16px; }
        .notion-settings summary { font-size: 13px; color: #86868b; cursor: pointer; margin-bottom: 8px; }
        .notion-settings input { margin-bottom: 8px; }
        .item-header { display: flex; justify-content: space-between; align-items: flex-start; }
        .item-body { flex: 1; }
        .save-btn { background: none; border: 1px solid #d2d2d7; border-radius: 4px; width: 28px; height: 28px; font-size: 13px; font-weight: 700; cursor: pointer; color: #86868b; flex-shrink: 0; margin-left: 8px; margin-top: 2px; }
        .save-btn.saved { color: #34c759; border-color: #34c759; cursor: default; }
    </style>
</head>
<body>
    <div class="container">
        <input type="password" id="key" placeholder="OpenAI Key">
        <details class="notion-settings">
            <summary>Notion Settings</summary>
            <input type="password" id="nt" placeholder="Notion Integration Token">
            <input type="text" id="nd" placeholder="Notion Database ID">
        </details>
        <div class="main">
            <button id="btn">üé§</button>
            <div id="status">Tap to start</div>
        </div>
        <h3>History <span style="font-size:12px; color:#ff3b30; cursor:pointer" onclick="clearH()">Clear all</span></h3>
        <div id="list"></div>
    </div>

    <script>
        let rec;
        let chunks = [];
        let audioStream = null;
        let audioCtx = null;
        const btn = document.getElementById('btn');
        const list = document.getElementById('list');

        // „Çø„Ç§„É†„Ç¢„Ç¶„Éà‰ªò„Åçfetch
        function fetchWithTimeout(url, options, ms = 30000) {
            const controller = new AbortController();
            const timer = setTimeout(() => controller.abort(), ms);
            return fetch(url, { ...options, signal: controller.signal })
                .finally(() => clearTimeout(timer));
        }

        // AudioContext„ÅßÈü≥Â£∞„ÇíÂÜçÁîüÔºàiOSËá™ÂãïÂÜçÁîüÂà∂Èôê„ÇíÂõûÈÅøÔºâ
        async function playAudioBlob(blob) {
            const arrayBuffer = await blob.arrayBuffer();
            const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
            const source = audioCtx.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(audioCtx.destination);
            source.start();
            return new Promise(resolve => { source.onended = resolve; });
        }

        window.onload = () => {
            render();
            const savedKey = localStorage.getItem('k');
            if(savedKey) document.getElementById('key').value = savedKey;
            const savedNt = localStorage.getItem('nt');
            if(savedNt) document.getElementById('nt').value = savedNt;
            const savedNd = localStorage.getItem('nd');
            if(savedNd) document.getElementById('nd').value = savedNd;
            document.getElementById('nt').addEventListener('change', e => localStorage.setItem('nt', e.target.value));
            document.getElementById('nd').addEventListener('change', e => localStorage.setItem('nd', e.target.value));
        };

        // „Éû„Ç§„ÇØ„Çπ„Éà„É™„Éº„É†„ÇíÂÆåÂÖ®„Å´ÂÅúÊ≠¢„Åô„ÇãÈñ¢Êï∞
        function stopStream() {
            if (audioStream) {
                audioStream.getTracks().forEach(track => track.stop());
                audioStream = null;
            }
        }

        btn.onclick = async () => {
            const k = document.getElementById('key').value;
            if(!k) return alert("Enter OpenAI API Key");
            localStorage.setItem('k', k);

            // AudioContext„Çí„É¶„Éº„Ç∂„ÉºÊìç‰ΩúÊôÇ„Å´ÂàùÊúüÂåñ/ÂÜçÈñãÔºàiOSÂØæÁ≠ñÔºâ
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                await audioCtx.resume();
            }

            // Èå≤Èü≥ÂÅúÊ≠¢
            if(rec && rec.state === "recording") {
                rec.stop();
                return;
            }

            try {
                // ‰ª•Ââç„ÅÆ„Çπ„Éà„É™„Éº„É†„Åå„ÅÇ„Çå„Å∞Á¢∫ÂÆü„Å´ÂÅúÊ≠¢
                stopStream();

                // „Éû„Ç§„ÇØ„ÅÆÊ®©Âà©„ÇíÊñ∞Ë¶èÂèñÂæóÔºàBluetooth„ÅÆÊé•Á∂ö„É™„Çª„ÉÉ„Éà„Çí‰øÉ„ÅôÔºâ
                audioStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    } 
                });

                const type = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') ? 'audio/webm;codecs=opus' : 'audio/mp4';
                rec = new MediaRecorder(audioStream, { mimeType: type });
                
                chunks = [];
                rec.ondataavailable = e => { if(e.data.size > 0) chunks.push(e.data); };
                
                rec.onstop = async () => {
                    btn.classList.remove('rec'); btn.innerText = "üé§";
                    
                    // Èå≤Èü≥Áõ¥Âæå„Å´„Çπ„Éà„É™„Éº„É†„ÇíÂÅúÊ≠¢„Åó„Å¶„Éû„Ç§„ÇØ„ÇíËß£ÊîæÔºàAirPodsÂÜçÁîü„Å∏„ÅÆÂàá„ÇäÊõø„Åà„Çí„Çπ„É†„Éº„Ç∫„Å´„Åô„ÇãÔºâ
                    stopStream();

                    const blob = new Blob(chunks, { type: rec.mimeType });
                    processAudio(blob, k, type);
                };
                
                rec.start();
                btn.classList.add('rec'); btn.innerText = "‚ñ†";
                document.getElementById('status').innerText = "Recording...";
            } catch(e) { 
                alert("Mic error: " + e.message); 
                document.getElementById('status').innerText = "Mic access denied";
            }
        };

        async function processAudio(blob, k, mimeType) {
            if (blob.size < 1000) {
                document.getElementById('status').innerText = "Too short or silent";
                return;
            }

            try {
                document.getElementById('status').innerText = "Thinking...";
                
                const fd = new FormData();
                const ext = mimeType.includes('webm') ? 'webm' : 'm4a';
                fd.append("file", blob, `audio.${ext}`);
                fd.append("model", "whisper-1");
                fd.append("language", "ja");

                // 1. Whisper (Èü≥Â£∞Ë™çË≠ò)
                const sttResponse = await fetchWithTimeout("https://api.openai.com/v1/audio/transcriptions", {
                    method: "POST", headers: { "Authorization": `Bearer ${k}` }, body: fd
                }, 30000);
                const sttData = await sttResponse.json();
                const jp = sttData.text;

                if(!jp || jp.trim().length === 0) {
                    document.getElementById('status').innerText = "Could not hear you";
                    return;
                }

                // Â±•Ê≠¥„Å´Êó•Êú¨Ë™û„ÇíÂÖàË°åË°®Á§∫
                const id = Date.now();
                list.insertAdjacentHTML('afterbegin', `
                    <div class="item" id="${id}">
                        <div class="label">In</div><div class="in">${jp}</div>
                        <div class="label">Out</div><div class="out" id="out-${id}">...</div>
                    </div>
                `);

                // 2. GPT-4o-mini (ÁøªË®≥)
                const gptResponse = await fetchWithTimeout("https://api.openai.com/v1/chat/completions", {
                    method: "POST", headers: { "Authorization": `Bearer ${k}`, "Content-Type": "application/json" },
                    body: JSON.stringify({
                        model: "gpt-4o-mini",
                        messages: [
                            {role:"system", content:"Translate the following Japanese to natural English. Return only the translated text."},
                            {role:"user", content:jp}
                        ]
                    })
                }, 15000);
                const gptData = await gptResponse.json();
                const en = gptData.choices[0].message.content;

                const outEl = document.getElementById(`out-${id}`);
                outEl.innerText = en;
                outEl.onclick = () => sp(en);

                // 3. TTS (Èü≥Â£∞ÂêàÊàê)
                const ttsResponse = await fetchWithTimeout("https://api.openai.com/v1/audio/speech", {
                    method: "POST", headers: { "Authorization": `Bearer ${k}`, "Content-Type": "application/json" },
                    body: JSON.stringify({ model: "tts-1", voice: "alloy", input: en })
                }, 15000);

                const audioBlob = await ttsResponse.blob();
                try {
                    await playAudioBlob(audioBlob);
                } catch(playErr) {
                    console.error("Audio play failed:", playErr);
                }
                document.getElementById('status').innerText = "Tap to start";

                // Â±•Ê≠¥„ÇíLocalStorage„Å∏‰øùÂ≠ò
                const h = JSON.parse(localStorage.getItem('h') || '[]');
                h.unshift({ jp, en, saved: false });
                localStorage.setItem('h', JSON.stringify(h.slice(0, 30)));
                render();

            } catch(e) {
                const msg = e.name === 'AbortError' ? "Error: Timeout" : "Error: API limit or key issue";
                document.getElementById('status').innerText = msg;
                console.error(e);
            }
        }

        function hasNotionConfig() {
            return !!(localStorage.getItem('nt') && localStorage.getItem('nd'));
        }

        async function saveToNotion(index) {
            const h = JSON.parse(localStorage.getItem('h') || '[]');
            const item = h[index];
            if (!item || item.saved) return;

            const btnEl = document.getElementById(`nb-${index}`);
            btnEl.innerText = '...';
            btnEl.disabled = true;

            try {
                const res = await fetch('/api/notion', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        token: localStorage.getItem('nt'),
                        database_id: localStorage.getItem('nd'),
                        japanese: item.jp,
                        english: item.en,
                    }),
                });
                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.error || 'Failed');
                }
                item.saved = true;
                localStorage.setItem('h', JSON.stringify(h));
                btnEl.innerText = '\u2713';
                btnEl.classList.add('saved');
            } catch (e) {
                alert('Notion save failed: ' + e.message);
                btnEl.innerText = 'N';
                btnEl.disabled = false;
            }
        }

        function render() {
            const h = JSON.parse(localStorage.getItem('h') || '[]');
            const nc = hasNotionConfig();
            list.innerHTML = h.map((i, idx) => `
                <div class="item">
                    <div class="item-header">
                        <div class="item-body">
                            <div class="label">In</div><div class="in">${i.jp}</div>
                            <div class="label">Out</div><div class="out" onclick="sp('${i.en.replace(/'/g,"")}')">${i.en}</div>
                        </div>
                        ${nc ? `<button class="save-btn${i.saved ? ' saved' : ''}" id="nb-${idx}" onclick="${i.saved ? '' : `saveToNotion(${idx})`}" ${i.saved ? 'disabled' : ''}>${i.saved ? '\u2713' : 'N'}</button>` : ''}
                    </div>
                </div>
            `).join('');
        }

        function clearH() { 
            if(confirm('Clear all history?')) {
                localStorage.removeItem('h'); 
                render(); 
            }
        }

        async function sp(t) {
            const k = document.getElementById('key').value;
            if(!k) return;
            try {
                if (!audioCtx) {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (audioCtx.state === 'suspended') await audioCtx.resume();
                const res = await fetchWithTimeout("https://api.openai.com/v1/audio/speech", {
                    method: "POST", headers: { "Authorization": `Bearer ${k}`, "Content-Type": "application/json" },
                    body: JSON.stringify({ model: "tts-1", voice: "alloy", input: t })
                }, 15000);
                const blob = await res.blob();
                await playAudioBlob(blob);
            } catch(e) { console.error(e); }
        }
    </script>
</body>
</html>